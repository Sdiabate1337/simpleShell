# simpleShell

 
simple shell in C
26.07.2022
─
DIABATÉ SÉKOU
Elève ingénieur en cyberdéfense
overview
This project is part of a process of learning certain skills including the use of the C language and the understanding of the linux system.
Recreating the shell is a perfect answer to these requests.
Objectifs
in this project , I’ll learn :
how the linux shell works.
the different processes and functions involved.
clear working path to code it myself.
What’s a shell
The shell is a program that serves as a text-based interface between the kernel and the user. It takes the command inputs written from the user’s keyboard and passes them to the machine to execute them through the kernel.

Main steps
the prompt : infinite loop. 
The first step is to create an infinite loop that is always ready to take any command and prints the shell’s symbol.  –in the example above, the “~$”–

In this way we are setting a shell in an interactive mode.
We'll use the stdio.h librairie.It is a library that contains the functions to the input and output processes of the system.
At system startup, three streams of data are opened: stdio, stdout and stderr.
Each one of those represents a buffered stream contained in a file, which has a file descriptor. We will be working with those files inside our loop.
For the sake of a good start, this is the header we will be using for the main function:


The implementation of  a shell is divided into three parts: The Parser, The Executor, and Shell  Subsystems. 
The Parser:
 The Parser is the software component that reads the command line such as “ls ­-al” and puts it  into a data structure called Command Table that will store the commands that will be  executed.to learn more about parser full  implementation see at bottom of this document at  IV.
The Executor :
The executor will take the command table generated by the parser and for every  SimpleCommand in the array it will create a new process.It will also if necessary create pipes  to communicate the output of one process to the input of the next one.
Shell Subsystems 
Other subsystems that complete your shell are:
  ● Environment Variables: Expressions of the form ${VAR} are expanded with the  corresponding environment variable. Also the shell should be able to set, expand and  print environment vars.  
● Wildcards: Arguments of the form a*a are expanded to all the files that match them in  the local directory and in multiple directories . 
 ● Subshells: Arguments between `` (backticks) are executed and the output is sent as  input to the shell. 

parse the command
According to its definition, the parser allows us to store the different parts of our cmd without space in a table. we will create a function which will do that:
strtok() allows you to extract, one by one, all the syntactic elements (the tokens) of a string.
    char * strtok( char * string, const char * delimiters );
example:
we will also use the strdup() function to create a double of each token which will be into the cmd array.
the code of our parser:
we also need a function to free the cmd array after usage which is a 2D array:
create a process for the command and execute it
We have to use the syscall fork() to create a new process and launch our command in it.
La fonction fork permet à un programme en cours d’exécution de créer un nouveau processus. Le processus d’origine est appelé processus père, et il garde son PID, et le nouveau processus créé s’appelle processus fils, et possède un nouveau PID. Le processus père et le processus fils ont le même code source, mais la valeur retournée par fork permet de savoir si on est dans le processus père ou fils.
 La fonction fork retourne -1 en cas d’erreur, retourne 0 dans le processus fils, et retourne le PID du fils dans le processus père. Ceci permet au père de connaître le PID de son fils. 
To execute our command we will use the syscall execve().
The character **token is passed as an argument to execve(), using its first position toks[0]as the first argument, the remaining toks as the second argument and the third argument, which would receive an array of pointers to strings in the environment, will for now be defined as NULL.

notre algo:
on crée un processus avec fork() 
si la création échoue , on envoie un message d’erreur avec perror.
sinon si la la création réussit (pid >0), on fait attendre le processus père avec waitpid(pid fils, &status, 0) .le  deuxième paramètre de waitpid est un passage par adresse d’un entier qui donne des informations sur le statut du fils lorsqu’il se termine .et on lui envoie un signale pour l'arrêter avec kill(pid_t pid, sig) .plus de détail sur Linux manual page
sinon le processus enfant exécute la cmd ou exit si l’appel système execve() échoue.
l'implémentation:





handle Pipe and Input/Output Redirection 
























Using Lex/flex and Yacc to implement the Parser
These tools are used to  implement compilers, interpreters, and preprocessors.
A parser is divided into two parts: 
 A Lexical Analyzer or Lexer takes the input characters and  puts the characters together into words called tokens, and 
A syntaxical Analyser that processes the  tokens according to a grammar and builds the command table.  
Here is a diagram of the Shell with the Lexer, the Parser and the other components. 
The tokens are described in a file shell.l using regular expressions. The file shell.l is  processed with a program called lex that generates the lexical analyzer.  
The grammar rules used by  the parser are described in a file called shell.y using syntax  expressions we describe below. shell.y is processed with a program called yacc that  generates a parser program. 

This grammar is written in a format called “Backus­Naur Form”. For example cmd  [arg]* means a command, cmd, followed by 0 or more arguments, arg. The expression [ | cmd  [arg]* ]* represents the optional pipe subcommands where there might be 0 or more of them.  The expression [>filename] means that there might be 0 or 1  >filename redirections. The  [&] at the end means that the & character is optional. 
Examples of commands accepted by this grammar are: 
 ls –al 
 ls –al > out  
ls –al | sort >& out  
awk –f x.awk | sort –u < infile > outfile &
The Command Table  
The Command Table is an array of  SimpleCommand structs. A SimpleCommand struct  contains members for the command and arguments of a single entry in the pipeline.
                                                    ls ­al | grep me > file1  



The method SimpleCommand::insertArgument( char * argument ) inserts a new argument  into the SimpleCommand and enlarges the _arguments array if necessary. It also makes sure  that the last element is NULL since that is required for the exec() system call. 

The variables _outFile, _inputFile, _errFile will be NULL if no redirection was  done, or the name of the file they are being redirected to. 

The variables  _currentCommand and _currentCommand are static variables, that is  there is only one for the whole class. These variables are used to build the Command and  Simple command during the parsing of the command.

The Command and SimpleCommand classes implement the main data structure we will use  in the shell.

Implementing the Lexical Analyzer

The file shell.l is passed through lex/flex to generate a C file called lex.yy.c. This file  implements the scanner that the parser will use to translate characters into tokens.  
There are two parts in shell.l. The top part looks like this:
                           %{   #include  <string.h>
                                    #include "y.tab.h" 
                              %} 
This is a portion that will be inserted at the top of the file lex.yy.c directly without  modification that includes header files and variable definitions that you will use in the scanner.

The second portion delimited by %% looks like this.This portion contains the regular expressions that define the tokens formed by taking the  characters from standard input.


Adding the new tokens to shell.y(syntaxical analyser)
I will add the token names you created in the previous step into shell.y in the %token  section:

The following  figure separates the syntax of the shell into different parts that will be used to build the  grammar.


Creating Processes in Your Shell 
Start by creating a new process for each command in the pipeline and making the parent wait  for the last command. This will allow running simple commands such as “ls ­al”






Insérez votre texte ici Insérez votre texte ici Insérez votre texte ici Insérez votre texte ici Insérez votre texte ici Insérez votre texte ici.
